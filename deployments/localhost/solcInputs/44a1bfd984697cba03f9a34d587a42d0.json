{
  "language": "Solidity",
  "sources": {
    "contracts/stake.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\ncontract Stake {\r\n\r\n    error Stake__NotOpenForWithdrawal();\r\n    error Stake__sendMoreEth();\r\n    error Stake__deadlineNotReached();\r\n    error Stake__transferFailed();\r\n\r\n    enum StakeState {\r\n        CLOSE,\r\n        OPEN,\r\n        WINTEREST,\r\n        WOINTEREST\r\n    }\r\n\r\n    \r\n    uint256 public immutable deadline = block.timestamp + 3 minutes;\r\n    uint256 public constant threshold = 1 ether;\r\n    StakeState public _stakeState;\r\n\r\n    mapping ( address => uint256 ) public balances;\r\n    address[] stakers;\r\n\r\n    constructor() payable { \r\n        \r\n      (bool callSuccess, ) = payable(address(this)).call{value: msg.value}(\"\");  \r\n      if(!callSuccess){\r\n        revert Stake__transferFailed();\r\n      } \r\n      _stakeState = StakeState.OPEN;\r\n      \r\n    }\r\n\r\n    modifier waitTimer() {\r\n        if(block.timestamp < deadline){\r\n         revert Stake__deadlineNotReached();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function deposit() public payable {\r\n       if(msg.value <= 0 ){\r\n        revert Stake__sendMoreEth();\r\n       }\r\n       \r\n     balances[msg.sender] += msg.value;\r\n     stakers.push(msg.sender);\r\n    }\r\n\r\n    function withdrawWOinterest() public payable waitTimer {\r\n        _stakeState = StakeState.WOINTEREST;\r\n        uint256 amount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n      (bool callSuccess, ) = address(this).call{value: amount}(\"\");\r\n       if(!callSuccess){\r\n        revert Stake__transferFailed();\r\n      } \r\n     } \r\n\r\n     function amountDeposited () public view returns (uint256) {\r\n         return  address(this).balance;\r\n     }\r\n\r\n\r\n}"
    },
    "contracts/stakeFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\nimport \"./stake.sol\";\r\n\r\ncontract StakeFactory {\r\n   Stake[] public stakeAddrresses;\r\n\r\n\r\n   function createStake() public payable {\r\n    Stake stakeContract = new Stake{value: msg.value}();\r\n    stakeAddrresses.push(stakeContract);\r\n   }\r\n\r\n   function getStakeAddresses (uint256 _index) public view returns (address)  {\r\n    return address(stakeAddrresses[_index]);\r\n\r\n   }\r\n   function getNoofStakers() public view returns (uint256) {\r\n    return stakeAddrresses.length + 1 ;\r\n   }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}